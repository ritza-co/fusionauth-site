---
title: Migration From Ping Identity
description: Learn how to migrate your users to FusionAuth from Ping Identity.
section: lifecycle
subcategory: migrate users
tertcategory: bulk
---
import MappingUserAttributes from 'src/content/docs/lifecycle/migrate-users/bulk/_mapping-user-attributes.mdx';
import SocialLoginNote from 'src/content/docs/lifecycle/migrate-users/bulk/_social-login-note.mdx';
import SocialLoginMigration from 'src/content/docs/lifecycle/migrate-users/bulk/_social-login-migration.mdx';
import OtherEntitiesIntro from 'src/content/docs/lifecycle/migrate-users/bulk/_other-entities-intro.mdx';
import Aside from 'src/components/Aside.astro';
import InlineField from 'src/components/InlineField.astro';
import ScrollRef from 'src/components/ScrollRef.astro';
import SetUpFusionauth from 'src/content/docs/lifecycle/migrate-users/bulk/_set-up-fusionauth.mdx';
import CreateTestTenant from 'src/content/docs/lifecycle/migrate-users/bulk/_create-test-tenant.mdx';
import CreateTestApplication from 'src/content/docs/lifecycle/migrate-users/bulk/_create-test-application.mdx';
import CreateApiKeySocial from 'src/content/docs/lifecycle/migrate-users/bulk/_create-api-key-social.mdx';
import InlineUIElement from 'src/components/InlineUIElement.astro';
import GetScript from 'src/content/docs/lifecycle/migrate-users/bulk/_get-script.mdx';
import VerifyImport from 'src/content/docs/lifecycle/migrate-users/bulk/_verify-import.mdx';
import FinalDestination from 'src/content/docs/lifecycle/migrate-users/bulk/_final-destination.mdx';
import WhatNext from 'src/content/docs/lifecycle/migrate-users/bulk/_what-next.mdx';
import AdditionalSupport from 'src/content/docs/lifecycle/migrate-users/bulk/_additional-support.mdx';

export const migration_source_name = 'Ping Identity';
export const migration_source_dir = 'ping';
export const script_supports_social_logins = 'true';
export const add_tenant_image_role = 'bottom-cropped';

## Overview

This document will help you migrate from Ping Identity to FusionAuth.

This guide assumes you have installed FusionAuth. If you have not, please [view our installation guides](/docs/get-started/download-and-install) and install FusionAuth before you begin. For more general migration information, please view the [FusionAuth migration guide](/docs/lifecycle/migrate-users/bulk/general).

There are a number of different ways applications can be integrated with Ping IdentityServer, and it would be difficult to cover them all. This guide focuses on migrating user data, including profile data and passwords. However, Ping IdentityServer does not allow for password hash export. Therefore, you must perform a slow migration if you donâ€™t want to force users to reset their passwords.

Alternatively, you can do a bulk migration and force everyone to reset their passwords. This option is discussed below, but the primary focus of this guide is enabling you to migrate your users from Ping IdentityServer without requiring any password resets.

## Planning Considerations

### Slow Migration or Bulk Migration

To preserve your users' passwords, you need to perform a slow migration. Users log in to FusionAuth with their Ping IdentityServer credentials, and FusionAuth transparently migrates their data. Slow migrations in FusionAuth use Connectors, a paid feature.

If, on the other hand, resetting user passwords is acceptable, a <ScrollRef target="Bulk Migration" /> can work for you. Review that section for more details on the required steps. You may also perform a bulk migration after a slow migration has run for a while. Active users can be transparently migrated and infrequent users may not mind resetting their password.

You can learn more about the [types of migrations that FusionAuth supports here](/docs/lifecycle/migrate-users/bulk/general#types-of-migrations).

### Mapping User Attributes

<MappingUserAttributes migration_source_name={migration_source_name} />

### One Tenant or Many

The PingIdentity platform uses an organization-based model to define tenant accounts and their related entities. The organization is the top-level identifier. It defines your entire enterprise within the platform.
(https://docs.pingidentity.com/r/en-us/pingone/p1_c_introduction). FusionAuth also has the concept of [Tenants](/docs/get-started/core-concepts/tenants). Both of these include data about users, applications and other configuration.

Each tenant in FusionAuth is a distinct user space. You may choose to merge multiple PingOne organizations into one FusionAuth tenant or keep them separate.

Learn more about [FusionAuth tenants](/docs/extend/examples/multi-tenant).

### Identity Providers

With PingIdentity , you can use the PingOne user directory or an external identity provider (IdP). Using an external IdP allows linked users to authenticate using the credentials provided by the external IdP. An external IdP includes mapping PingOne user attributes to attributes from the IdP(https://docs.pingidentity.com/r/en-us/pingone/p1_c_identityproviders). 
With FusionAuth, these are also called [Identity Providers](/docs/lifecycle/authenticate-users/identity-providers/).

Review the supported FusionAuth [Identity Providers](/docs/lifecycle/authenticate-users/identity-providers/) to ensure any you need are supported. At this time, while there is considerable overlap between the supported identity providers, there are a number of differences.

If not supported explicitly, a provider may work with an OIDC or SAML connection. Otherwise, please open a [feature request](https://github.com/fusionauth/fusionauth-issues/).

<Aside type="note">
Importing PingIdentity users stored in an external identity provider is more straightforward because you can use the Import API; you don't have to perform a slow migration. Many of the steps in <ScrollRef target="Bulk Migration" /> will apply.
</Aside>

To retrieve the user information, use the approach documented in the <ScrollRef target="Export User Data From PingIdentity" /> section.

<SocialLoginNote migration_source_name={migration_source_name} script_supports_social_logins={script_supports_social_logins} />

<SocialLoginMigration />

## Other Entities

<OtherEntitiesIntro other_migrated_entities="app clients or password policies" />

* PingIdentity uses Flows in Davinci. A flow is a user journey, such as registration or authentication, built from a set of capabilities and logical operators(https://docs.pingidentity.com/r/en-us/davinci/davinci_flows). FusionAuth has a similar concept called [Lambdas](/docs/extend/code/lambdas/). FusionAuth also has [webhooks](/docs/extend/events-and-webhooks/) fired at certain points in the user lifecycle; in certain configurations, they can also stop a particular authentication flow.
* In PingIdentity a role is a collection of permissions that can be assigned to a user, application, or connection(https://docs.pingidentity.com/r/en-us/pingone/p1_c_roles). FusionAuth has [roles](/docs/get-started/core-concepts/roles) that are configured on an application by application basis and made available in a token after a successful authentication.
* PingIdentity also allows using groups to organize a collection of user identities can make it easier to manage access to applications(https://docs.pingidentity.com/r/en-us/pingone/p1_c_groups).
* PingIdentity also makes use of populations:A population defines a set of users and can help you make user management simple(https://docs.pingidentity.com/r/en-us/pingone/p1_c_populations).
* pingidentity uses DaVinci, an orchestration platform that lets you create flows using connections and logical operators. These flows guide users through defined processes that can present customized pages, modify values, or perform other actions(https://docs.pingidentity.com/r/en-us/davinci/davinci_landing_page). In FusionAuth, [Applications](/docs/get-started/core-concepts/applications) are a similar construct, but users are associated with them through [Registrations](/docs/get-started/core-concepts/registrations). You can migrate both your Client Id and Client Secret from Azure AD B2C to FusionAuth.
* PingIdentity sends emails on your behalf, such as forgot password notifications. FusionAuth can do so too; [the templates are customizable](/docs/customize/email-and-messages/).
* PingIdentity Client Credentials grant. FusionAuth offers a constrained version of this using [Entity Management](/docs/get-started/core-concepts/entity-management); this is available in all paid editions.
* PingIdentity allows for custom attributes, but they must be configured at the Directory level. In FusionAuth, as mentioned above, custom user attributes are stored on the `user.data` field and are dynamic, searchable and unlimited in size. Any valid JSON value may be stored in this field.
* PingIdentity supports MFA. FusionAuth also [supports MFA](/docs/lifecycle/authenticate-users/multi-factor-authentication), which may be enabled for a tenant and configured for a user at any time.

<Aside type="note">
In FusionAuth, users are explicitly mapped to applications with a [Registration](/docs/get-started/core-concepts/registrations).
In PingIdentity 
    * Users gets assigned to a directory in the environment as partof an organization.
    * These users then by default gets access to the applications defined in the this environment. but might be dependent on certain roles.
</Aside>

#### Identifiers

<Identifiers />

#### Differences

In addition to the different names for common functionality outlined above in <ScrollRef target="Other Entities" />, there are some fundamental differences between FusionAuth and PingIdentity. If your application relies on PingIdentity specific functionality, please review this section carefully.

* PingIdentity has certain pricing limitions (https://www.pingidentity.com/en/company/contact-sales.html), like number . FusionAuth has no user limit. Instead, you are limited by the resources provided to a FusionAuth instance, such as memory, CPU and database capacity.
* FusionAuth does not support custom scopes. There is an [open feature request](https://github.com/FusionAuth/fusionauth-issues/issues/275).

Once you've planned the migration of other entities, the next step is to set up FusionAuth to connect to PingIdentity to import users during login.

### Login UI

PingIdentityServer allows cusom branding and themeing on the ui. Login pages are highly variable across  PingIdentity instances(https://docs.pingidentity.com/r/en-us/pingone/p1_c_branding_themes).

FusionAuth's login experience follows two paths. You can choose to build your own login pages or use FusionAuth's hosted login pages. [Read more about these choices](/docs/get-started/core-concepts/integration-points#login-options).

## Exporting Users

PingIdentity provides a rest api to performa management functions.(https://apidocs.pingidentity.com/pingone/platform/v1/api/#get-read-user-or-users). One of these endpoints allow you to read the user information in json format,

We recommend exporting your user information in JSON format so that you can import the data into FusionAuth using the FusionAuth API. 

### Create a User File

We've created a sample python export program to export users from a PingIdentity Server  to a JSON file.  You can find the folder with the source code for the export program [here](./pingidentity_export_users.py)

Clone the repo and open the solution in Visual Studio Code. 

The following fields need to be populated from your environment:
* envID = the id of the environment from where the users will be exported.
* access_token = To connect to the api and export the users, you will need to create a worker Apllication in your enviroment. Provide sufficient permissions to acceess your user data and also generate a Accss token, to use in the Export application.  

Make  sure the requirements (#pip install requests) for the python script is installed. Run the script  Once the export is complete, you should have a JSON file called `users.json` containing user objects that look something like this:

```json
{
    "_links": {
        "self": {
            "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users?limit=100"
        }
    },
    "_embedded": {
        "users": [
            {
                "_links": {
                    "password": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/password"
                    },
                    "password.set": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/password"
                    },
                    "account.sendVerificationCode": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c"
                    },
                    "linkedAccounts": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/linkedAccounts"
                    },
                    "self": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c"
                    },
                    "password.check": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/password"
                    },
                    "password.reset": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/password"
                    },
                    "password.recover": {
                        "href": "https://api.pingone.com/v1/environments/24f17b5b-a458-4238-973e-0f77401897ed/users/916b9057-1de6-4718-931d-91f9e886316c/password"
                    }
                },
                "id": "916b9057-1de6-4718-931d-91f9e886316c",
                "environment": {
                    "id": "24f17b5b-a458-4238-973e-0f77401897ed"
                },
                "account": {
                    "canAuthenticate": true,
                    "status": "OK"
                },
                "address": {
                    "streetAddress": "115 Randy Park",
                    "locality": "Cookshire-Eaton",
                    "countryCode": "CA"
                },
                "createdAt": "2024-02-14T16:28:27.845Z",
                "email": "hearthfield_berengere@example.com",
                "enabled": true,
                "identityProvider": {
                    "type": "PING_ONE"
                },
                "lifecycle": {
                    "status": "ACCOUNT_OK"
                },
                "mfaEnabled": false,
                "name": {
                    "formatted": "Hearthfield BÃ©rengÃ¨re",
                    "given": "Hearthfield",
                    "family": "BÃ©rengÃ¨re"
                },
                "population": {
                    "id": "5a899957-18d8-4a62-9a15-e7d4a5265bf8"
                },
                "updatedAt": "2024-02-14T16:28:27.845Z",
                "username": "hearthfield_bÃ©rengÃ¨re",
                "verifyStatus": "NOT_INITIATED"
            }, .......
```
but is transformed to something  similar to this , which is the output to users.json file in the same folder as the script.

```json
{
	"users": [
		{
			"active": true,
			"birthDate": null,
			"insertInstance": null,
			"data": {
				"migrated": true,
				"favoriteColors": null
			},
			"email": "hearthfield_berengere@example.com",
			"expiry": null,
			"firstName": "",
			"fullName": "",
			"id": "916b9057-1de6-4718-931d-91f9e886316c",
			"lastLoginInstant": 0,
			"lastName": "",
			"middleName": "",
			"mobilePhone": "",
			"password": null,
			"salt": null,
			"factor": 10000,
			"encryptionScheme": "salted-pbkdf2-hmac-sha256",
			"passwordChangeRequired": false,
			"passwordLastUpdateInstant": 0,
			"preferredLanguages": [
				"en"
			],
			"identityProviders": {
			},
			"timezone": null,
			"twoFactorEnabled": false,
			"username": "hearthfield_bÃ©rengÃ¨re",
			"verified": true
		},
		{
			"active": true,
			"birthDate": null,
			"insertInstance": null,
			"data": {
				"migrated": true,
				"favoriteColors": null
			},
			"email": "wingar_helena@example.com",
			"expiry": null,
			"firstName": "",
			"fullName": "",
			"id": "a7ff34b6-dfa1-4d60-abd7-5614eb21c8dc",
			"lastLoginInstant": 0,
			"lastName": "",
			"middleName": "",
			"mobilePhone": "",
			"password": null,
			"salt": null,
			"factor": 10000,
			"encryptionScheme": "salted-pbkdf2-hmac-sha256",
			"passwordChangeRequired": false,
			"passwordLastUpdateInstant": 0,
			"preferredLanguages": [
				"en"
			],
			"identityProviders": {
			},
			"timezone": null,
			"twoFactorEnabled": false,
			"username": "wingar_hÃ©lÃ¨na",
			"verified": true
		}
	]
}
```

Check the output for any errors and to make sure the data looks correct. If you have any issues, you can modify the export program to output more information about the users being exported.

Also check if there are any <InlineField>encryptionScheme</InlineField> values that are set to  no standard values. If there are, you will need to create a custom hashing plugin for FusionAuth. 

This is covered in detail in the <ScrollRef target="TODO Hashing Plugin" /> section further on in this guide.

## Importing Users ( Bulk Migration)

<Aside type="note">
This section is only needed if you decided not to do the SLow migration from the next sectiom. Be aware that this section  will not export password hashes and users will need to change it manually on fusion auth.
</Aside>

Remember the bulk migration does not allow the password hashes to be exported, so this method requires the user to change password on FusionAuth manually.

Next, import the user data. Here are the steps we need to take.

1. Set Up FusionAuth.
2. Get the Script.
3. Install Needed Gems.
4. Use the Script.
5. Verify the Import.
6. The Final Destination of Imported Users.

### Set Up FusionAuth

<SetUpFusionauth />

#### Create a Test Tenant

<CreateTestTenant migration_source_dir={migration_source_dir} migration_source_name={migration_source_name} add_tenant_image_role={add_tenant_image_role} />

#### Create a Test Application

<CreateTestApplication migration_source_dir={migration_source_dir} migration_source_name={migration_source_name} />

#### Add an API Key

<CreateApiKeySocial migration_source_dir={migration_source_dir} />

#### TODO Hashing Plugin

This IS still outstanding



### Get the Script

<GetScript />

### Install Needed Gems

The following gems must be available to the import script:

* `date`
* `json`
* `optparse`
* `securerandom`
* `fusionauth_client`

It is likely that all of these will be on your system already, except the `fusionauth_client` gem.

If you have `bundler` installed, run `bundle install` in the `duende` directory. Otherwise, install the needed gems another way.

### Use the Script

You can see the output of the script by running it with the `-h` option:

```sh title="Running the import script with the help command line switch"
ruby ./import.rb -h
```

The output will be similar to this:

```sh title="The help output of the import.rb script"
Usage: import.rb [options]
    -l, --link-social-accounts       Link social accounts, if present, after import. This operation is slower than an import.
    -r APPLICATION_IDS,              A comma separated list of existing applications Ids. All users will be registered for these applications.
        --register-users
    -o, --only-link-social-accounts  Link social accounts with no import.
    -u, --users-file USERS_FILE      The exported JSON user data file from IdentityServer. Defaults to users.json.
    -f FUSIONAUTH_URL,               The location of the FusionAuth instance. Defaults to http://localhost:9011.
        --fusionauth-url
    -k, --fusionauth-api-key API_KEY The FusionAuth API key.
    -t TENANT_ID,                    The FusionAuth tenant id. Required if more than one tenant exists.
        --fusionauth-tenant-id
    -h, --help                       Prints this help.
```

For this script to work correctly, set the following switches, unless the defaults work for you:

* `-u` should point to the location of the user export file you obtained, unless the default works.
* `-f` should point to your FusionAuth instance. If you are testing locally, it will probably be `http://localhost:9011`.
* `-k` should be set to the value of the API key created above.
* `-t` should be set to the Id of the testing tenant created above.

The `-o` and `-l` switches will attempt to create links for any users authenticated via Google or another social identity provider found in the users data file.

If you are loading users with social account authentication, you must create the social identity providers in FusionAuth beforehand or the links will fail. Additionally, creating a link is not currently optimized in the same way that loading a user is. It may make sense to import all the users in one pass (omitting the `-l` switch) and then create the links using the `-o` switch in a second pass, after the users are imported.

<Aside type="note">
The social account linking functionality will only work with FusionAuth version 1.28 or above. The `fusionauth_client` library must be >= 1.28.
</Aside>

When you run the script, you should get an output similar to the following:

```shell title="Import script output"
$ ruby ./import.rb -f http://localhost:9011 -k '...' -t '...' -u users.json
FusionAuth Importer : IdentityServer
 > User file: users.json
 > Call FusionAuth to import users
 > Import success
Duplicate users 0
Import complete. 2 users imported.
```

#### Enhancing the Script

You may want to migrate additional data. Currently, the following attributes are migrated:

* `user_id`
* `email`
* `email_verified`
* `username`
* `insertInstance`
* the password hash and supporting attributes, if available
* `registrations`, if supplied

The migrated user will have the original Ping IdentityServer user Id. If you have additional user attributes to migrate, review and modify the `map_user` method.

You may also want to assign Roles or associate users with Groups by creating the appropriate JSON data structures in the import call. These are documented in the [Import User API docs](/docs/apis/users#import-users). This will require modifying the `import.rb` code.

### Slow Migration

<Aside type="note">
This section is only if you decided to do the slow migration and can be ignored if the users changed their passwords as in the previous section
</Aside>

#####TODO
### Set Up Azure AD B2C

There are three main components you need to set up to enable this migration.

The first is an App Registration, with an [ROPC flow](https://docs.microsoft.com/en-us/azure/active-directory-b2c/add-ropc-policy?tabs=app-reg-ga&pivots=b2c-user-flow).

Secondly, you will need to set up a [Microsoft Graph application](https://docs.microsoft.com/en-us/azure/active-directory-b2c/microsoft-graph-get-started?tabs=app-reg-ga) to retrieve the user's details, in order to import them to FusionAuth.

The third is an [Azure Function](https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview) to accept login requests from FusionAuth over TLS and perform an [ROPC login](https://docs.microsoft.com/en-us/azure/active-directory-b2c/add-ropc-policy?tabs=app-reg-ga&pivots=b2c-user-flow) request on Azure AD B2C, and return the relevant user data via the Azure AD B2C Graph API app.

<Aside type="caution">
FusionAuth Connectors will send user credentials to Azure AD B2C for authentication, via an Azure Function. Secure both the data in transit and the Azure Function endpoint.

In this guide, all communication is over TLS and the Azure Function requires a unique query string code. You should also review the documents on [Securing Azure Functions](https://docs.microsoft.com/en-us/azure/azure-functions/security-concepts?tabs=v4) to implement any additional security features you may require.

Also note that the Azure AD B2C ROPC endpoint is monitored by rate limiting and identity protection systems. If a dynamic threshold of failed authentications is exceeded, the identity protection system may identify a repeated IP address (i.e. the Azure Function) as an attacker. You may need to deploy Functions to multiple regions, or perhaps self-host the function on a known IP address to mitigate potential issues.
</Aside>

#### Configuring the App Registration in Azure AD B2C

FusionAuth will send login requests to Azure AD B2C to validate the users credentials, via the Azure Function. It will also retrieve the users Azure AD B2C profile from the Microsoft Graph API. It is best practice to create new App Registrations for each of the ROPC flow and Microsoft Graph connection. This guide will walk through the configurations using the Azure Portal.

<Aside type="note">
These instructions use the newer [App Registrations](https://docs.microsoft.com/en-us/azure/active-directory-b2c/app-registrations-training-guide) (as opposed to the legacy Applications) experience.
</Aside>

Visit the [Azure AD B2C App Registrations](https://aka.ms/b2cappregistrations) tab. Then [follow these instructions](https://docs.microsoft.com/en-us/azure/active-directory-b2c/add-ropc-policy?tabs=app-reg-ga&pivots=b2c-user-flow#register-an-application) to set up a new ROPC App Registration and Flow.

At the end, you'll end up with an app client configuration looking similar to this:

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/ropc-app-registration-configuration.png`} alt="Configuring an ROPC App Registration for migration." width="1200" role="bottom-cropped" />

Save the new configuration. On the list of app clients, you'll see your new one.

Record the Application (client) ID. This will be a GUID like `022c5902-d8ee-43b0-ac1f-c2719b799657`. Also record the ROPC flow name - this will be needed as part of the Function environment settings.

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/ropc-app-client-id.png`} alt="Finding the app client id." width="1200" role="bottom-cropped" />

Now you can set up the App Registration for the Microsoft Graph API access. Follow [this guide](https://docs.microsoft.com/en-us/azure/active-directory-b2c/microsoft-graph-get-started?tabs=app-reg-ga), including the "Create Client Secret" section. Record both the Client Secret, and the Application (client) ID as above.

Next, you'll need to set up an Azure Function to receive the login requests from FusionAuth and return the user's profile. The Function will pass the credentials on to Azure AD B2C and, when the authentication succeeds, retrieve the user's profile from Microsoft Graph, then return a FusionAuth friendly JSON object.

#### Configuring the Azure Function

The Azure Function receives the login request from FusionAuth, attempts to log the user in via ROPC, and then returns a FusionAuth user object on success. The Function will call the [Users](https://docs.microsoft.com/en-us/graph/api/user-get?view=graph-rest-1.0&tabs=http) API after successful authentication to get additional user attributes, which will then be transformed into a FusionAuth compatible format.

When setting this up, modify the example Function code provided in this guide. Here's the entire sample Azure Function, tested with the node 14 runtime:

<RemoteCode url="https://raw.githubusercontent.com/FusionAuth/fusionauth-example-ropc-azure-function/main/RopcProxyFunction/index.js"
            lang="javascript"
            title="Azure AD B2C Connector Function code" />

You will need to modify the `transformToFusionUserObject` function to match the properties of the users that you want to import. This converts the JSON returned from Azure AD B2C into the JSON format FusionAuth requires. You can see samples of both below. To modify this procedure, clone or fork the [repo for the full Function project](https://github.com/FusionAuth/fusionauth-example-ropc-azure-function), then make the changes in your local copy of the project.

The exact implementation depends on your Active Directory's custom attributes and business logic. You could, for example, give users certain FusionAuth roles, register them for more than one application or add them to a previously created FusionAuth group.

```json title="Sample User Data Response from Azure AD B2C"
{
  "@odata.context": "https://graph.microsoft.com/beta/$metadata#users",
  "value":
  [
      {
          "id": "2e255143-5592-4233-a5b9-15e4ba56dfbe",
          "deletedDateTime": null,
          "accountEnabled": true,
          "ageGroup": null,
          "businessPhones":
          [],
          "city": null,
          "createdDateTime": "2022-08-05T21:05:58Z",
          "creationType": null,
          "companyName": null,
          "consentProvidedForMinor": null,
          "country": null,
          "department": null,
          "displayName": "Erlich Bachman",
          "employeeId": null,
          "employeeHireDate": null,
          "employeeLeaveDateTime": null,
          "employeeType": null,
          "faxNumber": null,
          "givenName": "Erlich",
          "imAddresses":
          [],
          "infoCatalogs":
          [],
          "isManagementRestricted": null,
          "isResourceAccount": null,
          "jobTitle": null,
          "legalAgeGroupClassification": null,
          "mail": null,
          "mailNickname": "erlich_bachman.com#EXT#",
          "mobilePhone": null,
          "onPremisesDistinguishedName": null,
          "officeLocation": null,
          "onPremisesDomainName": null,
          "onPremisesImmutableId": null,
          "onPremisesLastSyncDateTime": null,
          "onPremisesSecurityIdentifier": null,
          "onPremisesSamAccountName": null,
          "onPremisesSyncEnabled": null,
          "onPremisesUserPrincipalName": null,
          "otherMails":
          [
              "erlich@aviato.com"
          ],
          "passwordPolicies": null,
          "postalCode": null,
          "preferredDataLocation": null,
          "preferredLanguage": null,
          "proxyAddresses":
          [],
          "refreshTokensValidFromDateTime": "2022-08-05T21:05:58Z",
          "securityIdentifier": "S-1-12-1-774197571-1110660498-3826629029-3202307770",
          "showInAddressList": null,
          "signInSessionsValidFromDateTime": "2022-08-05T21:05:58Z",
          "state": null,
          "streetAddress": null,
          "surname": "Bachman",
          "usageLocation": null,
          "userPrincipalName": "erlich_bachman.com#EXT#@fusiontut.onmicrosoft.com",
          "externalUserConvertedOn": null,
          "externalUserState": null,
          "externalUserStateChangeDateTime": null,
          "userType": "Member",
          "employeeOrgData": null,
          "passwordProfile": null,
          "assignedLicenses":
          [],
          "assignedPlans":
          [],
          "authorizationInfo":
          {
              "certificateUserIds":
              []
          },
          "deviceKeys":
          [],
          "identities":
          [
              {
                  "signInType": "federated",
                  "issuer": "MicrosoftAccount",
                  "issuerAssignedId": null
              },
              {
                  "signInType": "userPrincipalName",
                  "issuer": "fusiontut.onmicrosoft.com",
                  "issuerAssignedId": "erlich_bachman.com#EXT#@fusiontut.onmicrosoft.com"
              }
          ],
          "onPremisesExtensionAttributes":
          {
              "extensionAttribute1": null,
              "extensionAttribute2": null,
              "extensionAttribute3": null,
              "extensionAttribute4": null,
              "extensionAttribute5": null,
              "extensionAttribute6": null,
              "extensionAttribute7": null,
              "extensionAttribute8": null,
              "extensionAttribute9": null,
              "extensionAttribute10": null,
              "extensionAttribute11": null,
              "extensionAttribute12": null,
              "extensionAttribute13": null,
              "extensionAttribute14": null,
              "extensionAttribute15": null
          },
          "onPremisesProvisioningErrors":
          [],
          "provisionedPlans":
          []
      }
  ]
}
```

The `transformToFusionUserObject` will transform the above into a FusionAuth compatible format, as displayed below:

```json title="Sample Successful Login JSON"
{
  "user": {
    "id": "702eebc9-ef84-489f-b7d3-6f67388ffdd3",
    "active": true,
    "firstName": "Erlich",
    "fullName": "Erlich Bachman",
    "lastName": "Bachman",
    "username": "702eebc9-ef84-489f-b7d3-6f67388ffdd3@fusiontut.onmicrosoft.com",
    "email": "erlich.bachman@piedpiper.com",
    "verified": true,
    "insertInstant": 1661188751,
    "data": {
      "azure": {
        "identities": [
          {
            "signInType": "emailAddress",
            "issuer": "fusiontut.onmicrosoft.com",
            "issuerAssignedId": "erlich.bachman@piedpiper.com"
          },
          {
            "signInType": "userPrincipalName",
            "issuer": "fusiontut.onmicrosoft.com",
            "issuerAssignedId": "702eebc9-ef84-489f-b7d3-6f67388ffdd3@fusiontut.onmicrosoft.com"
          }
        ]
      }
    }
  }
}
```

Once you have the custom function logic updated, it is time to deploy the Azure Function.

#### Deploying the Azure Function

Azure Functions can be coded within the Azure portal directly, or coded on your local machine and deployed as a package using https://docs.microsoft.com/en-us/azure/azure-functions/functions-develop-vs-code?tabs=csharp[Visual Studio Code, with Azure Extensions]. As the function has dependent modules, you will need to follow these instructions. Clone the [function GitHub repo](https://github.com/FusionAuth/fusionauth-example-ropc-azure-function), and follow the instructions in the link to deploy to your Azure Function.

After deploying the Function, set the following Function environment variables, also known as [Application Settings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings?tabs=portal), to those that you recorded when setting up the ROPC app:

```bash title="Azure Connector Function environment variables to set"
TENANT_NAME:          // The name of your AD B2C Tenant,
ROPC_FLOW_NAME:       // The name of the ROPC flow setup above
ROPC_CLIENT_ID:       // The Client ID of the ROPC App Registration
GRAPH_CLIENT_ID:      // The Microsoft Graph API App Registration clientId, a.k.a Application id
GRAPH_CLIENT_SECRET:  // The Microsoft Graph API App Registration client secret
```

#### Testing The Deployed API

Once you have deployed the Function, copy the Function URL with the access code from the Azure Portal. You can do this by clicking the "Get Function URL" button on the top bar of the Function overview page. The URL should look something like this: `https://fusionAuth.azurewebsites.net/api/RopcProxy?code=s0ndU863xdbXsFO4dLZAJQXLzyTU789iaUJ43uLAtIkXm_AzFuFWP1zg==`.

Test the login process with the lambda. You can use curl and an account whose username and password you know to do so.

```shell title="Testing the API and Azure Function with Curl"
curl -X POST \
'https://fusionAuth.azurewebsites.net/api/RopcProxy?code=s0ndU863xdbXsFO4dLZAJQXLzyTU789iaUJ43uLAtIkXm_AzFuFWP1zg=='  -H 'Content-type: application/json' -d '{
  "loginId": "test@example.com",
  "password": "password"
}'
```

If the user is authenticated, you should receive a response similar, though differing based on how you modified the Function code, to this:

```json title="Successful Results of Testing the API and Azure Function"
{
  "user": {
    "id": "702eebc9-ef84-489f-b7d3-6f67388ffdd3",
    "active": true,
    "firstName": "Erlich",
    "fullName": "Erlich Bachman",
    "lastName": "Bachman",
    "username": "702eebc9-ef84-489f-b7d3-6f67388ffdd3@fusiontut.onmicrosoft.com",
    "email": "erlich.bachman@piedpiper.com",
    "verified": true,
    "insertInstant": 1661188751,
    "data": {
      "azure": {
        "identities": [
          {
            "signInType": "emailAddress",
            "issuer": "fusiontut.onmicrosoft.com",
            "issuerAssignedId": "erlich.bachman@piedpiper.com"
          },
          {
            "signInType": "userPrincipalName",
            "issuer": "fusiontut.onmicrosoft.com",
            "issuerAssignedId": "702eebc9-ef84-489f-b7d3-6f67388ffdd3@fusiontut.onmicrosoft.com"
          }
        ]
      }
    }
  }
}
```

If the authorization header or account credentials are incorrect, a 404 HTTP status code is returned, along with a message in the body. You can view the status code by running `curl` with the `-v` switch.

### Set Up the Connector

Now you need to set up a Connector to use the Azure AD B2C API you created. You should set up a different Connector for each Azure AD B2C Tenant.

Log back into the FusionAuth administrative user interface if needed.

<PremiumEditionBlurb />

Connectors are a feature limited to paid editions, so you must ensure you have a valid reactor license. Learn more about [activating reactor](/docs/get-started/core-concepts/licensing).

Next:

* Configure the Connector with the API URL and authorization header
* Configure the Tenant to use the Connector

#### Configure a Connector

Create and configure the Connector. Navigate to <strong>Settings -> Connectors</strong> and add a new Generic Connector.

Configure the Connector:

* Add a name like `Azure AD B2C migration`.
* Set the <InlineField>Authentication URL</InlineField> to the value of the Function URL endpoint created above.
* You don't need to set any headers, as Azure Functions have a code in the querystring.

At the end, you should have a screen like this:

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/configured-generic-connector.png`} alt="Configuring a Generic Connector." width="1200" role="bottom-cropped" />

Save the Connector. Next, configure your tenant to use this Connector.

#### Configuring the Tenant

Navigate to your tenant settings: <strong>Tenants -> Azure import tenant -> Connectors</strong>.

Click the <InlineField>Add policy</InlineField> button to set up a new Connector policy.

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/connector-policies.png`} alt="Connector policies for this Tenant." width="1200" role="bottom-cropped" />

Set the <InlineField>Connector</InlineField> field value to the name of the Connector created previously. Make sure that the <InlineField>Migrate user</InlineField> field is enabled. You can leave the <InlineField>Domains</InlineField> field with the value of `*`, which will apply this Connector to every user.

After configuration, the Policy entry form should look similar to this:

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/add-connector-policy.png`} alt="Add Connector policy." width="1200" />

Save it.

Next, ensure this Connector Policy is in the correct order by using the arrows in the administrative user interface to put it at the top. With this configuration, all users are checked against this Connector the first time they are seen. If they log in, they'll be migrated to the FusionAuth user database.

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/connector-policy-list-after-adding.png`} alt="Azure AD B2C Connector policy added and in list." width="1200" role="bottom-cropped" />

### Log In With a Test User

To test that users will be migrated, log in as a test user via the FusionAuth interface.

When you set up the test application, you recorded the <InlineField>OAuth IdP login URL</InlineField>.

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/find-login-url.png`} alt="Finding the login URL." width="1200" />

Copy this URL and open it in a new incognito browser window. (If you don't use an incognito window, the admin user session will interfere with the test.) You should see the login screen:

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/user-login.png`} alt="The login page." width="1200" role="bottom-cropped" />

Enter credentials for a Azure AD B2C user account; it can be the same one you used to test the API with curl and log in. The user will be transparently migrated over to FusionAuth.

If the user was not migrated or the login was unsuccessful, you can troubleshoot. In the administrative user interface, enable the <InlineField>Debug enabled</InlineField> field in the Connector configuration by navigating to <strong>Settings -> Connectors</strong> and editing the Generic Connector you added.

After enabling enhanced debug messages, try to log in again with the test user. In the administrative user interface, navigate to <strong>System -> Event Log</strong> and look for useful messages.

<Aside type="note">
After a successful test login, the user will be redirected to a URL like `https://example.com/?code=FlZF97WIYLNxt4SGD_22qvpRh4fZ6kg_N89ZbBAy1E4&locale=fr&userState=Authenticated`. This occurs because you haven't set up a web application to handle the authorization code redirect yet.

That is an important next step but is beyond the scope of this document. Consult the [5 minute setup guide](/docs/quickstarts/5-minute-setup-guide) for an example of how to do this.
</Aside>

Let's check that the import succeeded in another way: by viewing the user in the administrative user interface.

### Verify the Migration

<VerifyImport migration_source_dir={migration_source_dir} />


At this point, you've successfully migrated a user from Azure AD B2C into FusionAuth. Any further changes for this user will occur against the FusionAuth database; this includes profile and password changes.

### Clean Up Your Test Environment

After you are done testing, deploy these same configuration changes to production.

Depending on your architecture, you can choose to migrate users into the default tenant or a new tenant of the production instance. Whichever you choose, configure the Connector policy of the destination tenant.

If you aren't keeping users in the test tenant, delete it. This is also useful if you want to start over because you need to tweak a setting such as the default application registration. In either case, delete the tenant you created.

This will remove all the users and other configuration for this tenant, giving you a fresh start. To delete a tenant, navigate to <strong>Tenants</strong> and choose the red trash can icon corresponding to the tenant to be deleted.

<img src={`/img/docs/lifecycle/migrate-users/bulk/${migration_source_dir}/list-of-tenants-delete-highlighted.png`} alt="Deleting a tenant." width="1200" role="bottom-cropped" />

Confirm your desire to delete the tenant. Depending on how many users exist in that tenant, this may take some time. If it is easier, you may also delete migrated users one at a time using the administrative user interface.

### Migrate Everything Else
#####TODO


### Verify the Import

<VerifyImport migration_source_dir={migration_source_dir} />

### The Final Destination of Imported Users

<FinalDestination migration_source_dir={migration_source_dir} />

## What to Do Next

<WhatNext />

## Additional Support

<AdditionalSupport />
